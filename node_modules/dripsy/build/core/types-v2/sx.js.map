{"version":3,"file":"sx.js","sourceRoot":"","sources":["../../../src/core/types-v2/sx.ts"],"names":[],"mappings":"AAEA,OAAO,EAGL,SAAS,GACV,MAAM,gBAAgB,CAAA;AA0LvB,MAAM,GAAG,GAAO,EAAE,CAAA;AAElB,MAAM,EAAE,GAAO;IACb,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC;IACf,EAAE,EAAE,OAAO;IACX,OAAO,EAAE,IAAI;IACb,CAAC,EAAE,IAAI;IACP,SAAS,EAAE,MAAM;IACjB,WAAW,EAAE,OAAO;IACpB,eAAe,EAAE,aAAa;IAC9B,UAAU,EAAE,QAAQ;IACpB,cAAc,EAAE,CAAC,QAAQ,EAAE,UAAU,CAAC;IACtC,WAAW,EAAE,EAAE;IACf,WAAW,EAAE,OAAO;IACpB,IAAI,EAAE,CAAC;IACP,KAAK,EAAE,aAAa;IACpB,YAAY,EAAE;QACZ,MAAM,EAAE,EAAE;QACV,KAAK,EAAE,EAAE;KACV;CACF,CAAA;AAqDD,aAAa;AAEb,UAAU;AAEV,MAAM,SAAS,GAAG,SAAS,CAAC;IAC1B,MAAM,EAAE;QACN,KAAK,EAAE,OAAO;QACd,OAAO,EAAE;YACP,GAAG,EAAE,KAAK;YACV,GAAG,EAAE,MAAM;SACZ;KACF;IACD,KAAK,EAAE;QACL,EAAE,EAAE,CAAC;KACN;IACD,OAAO,EAAE;QACP,IAAI,EAAE;YACJ,WAAW,EAAE,OAAO;SACrB;KACF;IACD,IAAI,EAAE;QACJ,IAAI,EAAE,EAAE;KACT;IACD,KAAK,EAAE;QACL,oBAAoB,EAAE,IAAI;QAC1B,oBAAoB,EAAE;QACpB,oBAAoB;SACrB;KACF;CACF,CAAC,CAAA","sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\nimport type { ThemeUICSSProperties } from '@theme-ui/css'\nimport {\n  DripsyFinalTheme,\n  DripsyThemeWithoutIgnoredKeys,\n  makeTheme,\n} from './declarations'\nimport type { ImageStyle, TextStyle, ViewStyle, ColorValue } from 'react-native'\nimport type { AssertEqual, AssertTest, SmartOmit } from './type-helpers'\nimport type { Scales, Aliases } from '../css/scales'\nimport type { DripsyCustomTheme } from './declarations'\nimport { ComponentType } from 'react'\n\n// âœ…\ntype ThemeKeysWhichContainVariants = keyof Pick<\n  DripsyThemeWithoutIgnoredKeys<DripsyFinalTheme>,\n  | 'alerts'\n  | 'badges'\n  | 'buttons'\n  | 'cards'\n  | 'forms'\n  | 'grids'\n  | 'images'\n  | 'layout'\n  | 'links'\n  | 'messages'\n  | 'shadows'\n  | 'text'\n  | 'textStyles'\n  | 'styles'\n  | 'textShadows'\n>\n\nexport type ResponsiveValue<T> =\n  | T\n  | null\n  | undefined\n  | (null | T | undefined)[]\n  | readonly (null | T | undefined)[]\n\n// #region shadows\ntype WebShadowSx = {\n  boxShadow?: ResponsiveValue<(string & {}) | keyof DripsyFinalTheme['shadows']>\n  textShadow?: ResponsiveValue<\n    (string & {}) | keyof DripsyFinalTheme['textShadows']\n  >\n}\n\n// #endregion\n\n// #region react native styles\n\ntype NativeSx = {\n  transform?: ReactNativeTypesOnly extends true\n    ? ViewStyle['transform']\n    : ViewStyle['transform'] | (string & {})\n} & {\n  animationKeyframes?: Record<string, unknown>\n  animationDuration?: string\n  animationDelay?: string\n} & Pick<ViewStyle, 'shadowOffset'>\n\n// #endregion\n\n// #region Sx\n\ntype StyleableSxProperties = Exclude<\n  | Exclude<keyof ThemeUICSSProperties, 'textShadow' | 'boxShadow' | 'variant'>\n  | keyof ViewStyle\n  | keyof TextStyle\n  | keyof ImageStyle\n  | keyof DripsyFinalTheme['aliases'],\n  keyof NativeSx | keyof WebShadowSx\n>\n\ntype NativeStyleProperties = ViewStyle & TextStyle & ImageStyle\n\ntype MaybeNativeStyleValue<\n  StyleKeyOrAlias extends StyleableSxProperties,\n  StyleKey = AliasToStyleKey<StyleKeyOrAlias>\n> = StyleKey extends keyof NativeStyleProperties\n  ? NativeStyleProperties[StyleKey]\n  : MaybeThemeUiStyle<StyleKeyOrAlias>\n\ntype ReactNativeTypesOnly = NonNullable<\n  DripsyFinalTheme['types']\n>['reactNativeTypesOnly'] extends true\n  ? true\n  : false\n\ntype OnlyAllowThemeValuesInput<T extends DripsyFinalTheme = DripsyFinalTheme> = 'onlyAllowThemeValues' extends keyof NonNullable<T['types']> ? NonNullable<T['types']>['onlyAllowThemeValues'] : undefined;\n\ntype ThemeValuesOnlyForStyleKey<\n  StyleKeyOrAlias extends StyleableSxProperties,\n  Scale extends MaybeScaleFromStyleKeyOrAlias<StyleKeyOrAlias> = MaybeScaleFromStyleKeyOrAlias<StyleKeyOrAlias>\n> = OnlyAllowThemeValuesInput extends 'always'\n  ? true\n  : OnlyAllowThemeValuesInput extends Record<string, unknown>\n  ? Scale extends keyof OnlyAllowThemeValuesInput\n    ? true\n    : false\n  : false\n\n// type ThemeValuesOnlyForStyleKeyTest = AssertEqual<\n//   ThemeValuesOnlyForStyleKey<'color'>,\n//   true\n// >\n// type ThemeValuesOnlyForStyleKeyTest2 = AssertEqual<\n//   ThemeValuesOnlyForStyleKey<'padding'>,\n//   false\n// >\n// type ThemeValuesOnlyForStyleKeyTest3 = AssertEqual<\n//   ThemeValuesOnlyForStyleKey<'alignItems'>,\n//   false\n// >\n\ndeclare const b: ThemeValuesOnlyForStyleKey<'alignItems'>\n\ntype MaybeThemeUiStyle<\n  StyleKey extends StyleableSxProperties\n> = ReactNativeTypesOnly extends true\n  ? undefined\n  : StyleKey extends keyof ThemeUICSSProperties\n  ? ThemeUICSSProperties[StyleKey]\n  : undefined\n\ntype SxValue<\n  StyleKey extends StyleableSxProperties\n> = ThemeValuesOnlyForStyleKey<StyleKey> extends true\n  ? MaybeTokenFromStyleKey<StyleKey>\n  : MaybeTokenFromStyleKey<StyleKey> extends undefined\n  ? MaybeNativeStyleValue<StyleKey> | (string & {})\n  : // we add this string & number thing so that they can use other values from RN. it's the only way i think\n    MaybeTokenFromStyleKey<StyleKey> | (string & {}) | number\n\n// you can circumvent theme values only with the factory\ntype FactoryValue<T> =\n  | T\n  | ((theme: DripsyFinalTheme) => T | (string & {}) | number)\n\ntype AllVariantSets = {\n  [K in keyof DripsyCustomTheme as K extends ThemeKeysWhichContainVariants\n    ? K\n    : never]: DripsyFinalTheme[K]\n}\n\ntype ValueOf<T> = T[keyof T]\n\ntype DotPath<T> = ValueOf<\n  {\n    [K in keyof T]: `${Extract<K, string | number>}.${Extract<\n      keyof T[K],\n      string | number\n    >}`\n  }\n>\n\ntype DotPathOrKeyOf<T> = ValueOf<\n  {\n    [K in keyof T]: T[K] extends Record<string | number, string>\n      ? `${Extract<K, string | number>}.${Extract<keyof T[K], string | number>}`\n      : K\n  }\n>\n\nexport type ColorPath = DotPathOrKeyOf<DripsyFinalTheme['colors']>\n\ntype DotPathOrKeyofTest = AssertEqual<\n  DotPathOrKeyOf<TestTheme['colors']>,\n  '$nested.100' | '$text'\n>\n\ntype DotPathColors = DotPathOrKeyOf<{\n  $here: {\n    100: 1\n  }\n}>\n\nexport type Variant = DotPath<AllVariantSets>\n\nexport type Sx = {\n  [StyleKey in StyleableSxProperties]?: FactoryValue<\n    ResponsiveValue<SxValue<StyleKey>>\n  >\n} &\n  NativeSx &\n  WebShadowSx & {\n    variant?: Variant\n  }\n\nexport type SxProp = Sx | ((theme: DripsyFinalTheme) => Sx)\n\nconst sx2: Sx = {}\n\nconst sx: Sx = {\n  height: () => 0,\n  bg: '$text',\n  padding: '$1',\n  m: '$1',\n  boxShadow: 'test',\n  shadowColor: '$text',\n  textShadowColor: '$nested.100',\n  alignItems: 'center',\n  justifyContent: ['center', 'flex-end'],\n  paddingLeft: 20,\n  borderColor: '$text',\n  flex: 1,\n  color: '$nested.100',\n  shadowOffset: {\n    height: 10,\n    width: 10,\n  },\n}\n\n// const sxProp: SxProp = (theme) => ({\n//   bg: '$text',\n//   borderRightWidth: theme.space.$1,\n//   borderTopWidth: '2px',\n// })\n\n// #endregion\n\n// #region scales\ntype MaybeScaleFromStyleKey<\n  StyleKey extends StyleableSxProperties\n> = StyleKey extends keyof Scales ? Scales[StyleKey] : undefined\n\ntype ScaleTests = {\n  space: MaybeScaleFromStyleKey<'padding'>\n  colors: MaybeScaleFromStyleKey<'backgroundColor'>\n}\n\ntype AssertedScaleTests = AssertTest<ScaleTests, ScaleTests>\n\ntype MaybeScaleFromStyleKeyOrAlias<\n  StyleKey extends StyleableSxProperties\n> = MaybeScaleFromStyleKey<AliasToStyleKey<StyleKey>>\n\ntype ScaleOrAliasTests = {\n  space: MaybeScaleFromStyleKeyOrAlias<'p'>\n  colors: MaybeScaleFromStyleKeyOrAlias<'bg'>\n}\n\ntype AssertedScaleOrAliasTests = AssertTest<\n  ScaleOrAliasTests,\n  ScaleOrAliasTests\n>\n// #endregion\n\n// #region aliases\ntype AliasToStyleKey<\n  StyleKeyOrAlias extends StyleableSxProperties\n> = StyleKeyOrAlias extends keyof Aliases\n  ? Aliases[StyleKeyOrAlias]\n  : StyleKeyOrAlias extends keyof DripsyFinalTheme['aliases']\n  ? DripsyFinalTheme['aliases'][StyleKeyOrAlias]\n  : StyleKeyOrAlias\n\ntype AliasTests = {\n  padding: AliasToStyleKey<'p'>\n  backgroundColor: AliasToStyleKey<'bg'>\n  margin: AliasToStyleKey<'m'>\n}\n\ntype AssertedAliasTests = AssertTest<AliasTests, AliasTests>\n// #endregion\n\n// testing\n\nconst testTheme = makeTheme({\n  colors: {\n    $text: 'color',\n    $nested: {\n      100: 'red',\n      200: 'blue',\n    },\n  },\n  space: {\n    $1: 1,\n  },\n  shadows: {\n    test: {\n      shadowColor: '$text',\n    },\n  },\n  text: {\n    body: {},\n  },\n  types: {\n    reactNativeTypesOnly: true,\n    onlyAllowThemeValues: {\n      // colors: 'always',\n    },\n  },\n})\ntype TestTheme = typeof testTheme\n\n// declare module './declarations' {\n//   // @ts-expect-error leave this here so we remember to comment out lol\n//   // eslint-disable-next-line @typescript-eslint/no-empty-interface\n//   interface DripsyCustomTheme extends TestTheme {}\n// }\n\n// #region tokens\ntype MaybeTokensObjectFromScale<\n  Key extends Scales[keyof Scales]\n> = Key extends keyof DripsyFinalTheme ? DripsyFinalTheme[Key] : never\n\ntype MaybeTokensFromScaleTest = AssertEqual<\n  MaybeTokensObjectFromScale<'colors'>,\n  DripsyFinalTheme['colors']\n>\n\ntype MaybeTokenOptionsFromScale<\n  Key extends Scales[keyof Scales] | undefined\n> = Key extends Scales[keyof Scales]\n  ? MaybeTokensObjectFromScale<Key> extends Record<string, unknown>\n    ? // ? `${Extract<keyof MaybeTokensObjectFromScale<Key>, string>}`\n      `${Exclude<DotPathOrKeyOf<MaybeTokensObjectFromScale<Key>>, symbol>}`\n    : undefined\n  : undefined\n\n// type MaybeTokenOptionsFromScaleTest = AssertEqual<\n//   keyof DripsyFinalTheme['colors'],\n//   MaybeTokenOptionsFromScale<'colors'>\n// >\n\ntype MaybeTokenFromStyleKey<\n  StyleKey extends StyleableSxProperties\n> = MaybeScaleFromStyleKeyOrAlias<StyleKey> extends undefined\n  ? undefined\n  : MaybeTokenOptionsFromScale<MaybeScaleFromStyleKeyOrAlias<StyleKey>>\n\n// type MaybeTokenOptionsFromStyleKeyTest = AssertEqual<\n//   MaybeTokenFromStyleKey<'bg'>,\n//   keyof DripsyFinalTheme['colors']\n// >\n\n// type MaybeTokenOptionsFromStyleKeyTest2 = AssertEqual<\n//   '$1',\n//   MaybeTokenFromStyleKey<'padding'>\n// >\n\n// type MaybeTokenOptionsFromStyleKeyTest3 = AssertEqual<\n//   MaybeTokenFromStyleKey<'alignItems'>,\n//   never\n// >\n\n// #region variants\nexport type MaybeVariantsFromThemeKey<\n  ThemeKey extends keyof DripsyFinalTheme | undefined\n> = ThemeKey extends keyof DripsyFinalTheme\n  ? DripsyFinalTheme[ThemeKey] extends Record<string, unknown>\n    ? Extract<keyof DripsyFinalTheme[ThemeKey], string>\n    : undefined\n  : undefined\n\n// const testVariant: MaybeVariantsFromThemeKey<'text'> = 'body'\n// #endregion\n\n// let a: MaybeTokenFromStyleKey<'alignItems'>\n\n// declare function testString<\n//   K extends StyleableSxProperties,\n//   U extends MaybeTokenFromStyleKey<K> extends never\n//     ? false\n//     : true = MaybeTokenFromStyleKey<K> extends never ? false : true\n// >(value: K, u: MaybeTokenFromStyleKey<K>): U\n\n// testString('color', '$text')\n// testString('alignItems', false as never)\n// #endregion\n\ntype VariantProp<\n  ThemeKey extends keyof DripsyFinalTheme | undefined | 'missing'\n> = ThemeKey extends 'missing' | undefined\n  ? Variant\n  : ThemeKey extends keyof DripsyFinalTheme\n  ? DripsyFinalTheme[ThemeKey] extends undefined\n    ? Variant\n    : MaybeVariantsFromThemeKey<ThemeKey>\n  : undefined\n\n// type TestVariant1 = AssertEqual<VariantProp<'text'>, 'body'>\n// type TestVariant2 = AssertEqual<VariantProp<undefined>, 'shadows.test'>\n\nexport type StyledProps<\n  // idk lol this hack with missing seems to work. without it the variant prop for View is empty. undefined might be weird\n  ThemeKey extends keyof DripsyFinalTheme | undefined | 'missing' = 'missing'\n> = {\n  as?: ComponentType\n  variant?: VariantProp<ThemeKey>\n  themeKey?: ThemeKey\n  sx?: SxProp\n  variants?: VariantProp<ThemeKey>[]\n}\n\nexport type ThemedOptions<\n  ExtraProps,\n  ThemeKey extends Extract<keyof DripsyFinalTheme, string> | undefined\n> = {\n  defaultStyle?: Sx | ((props: ExtraProps) => Sx)\n} & {\n  defaultVariant?: MaybeVariantsFromThemeKey<ThemeKey> | (string & {})\n  /**\n   * List of multiple variants\n   */\n  defaultVariants?: MaybeVariantsFromThemeKey<ThemeKey>[]\n  themeKey?: ThemeKey\n}\n"]}